<!--
{
  "title": "I'm unsatisfied with easing functions",
  "category": "blog",
  "date": "2025-07-20",
  "excerpt": "TODO",
  "thumbnail": "%root%/content/images/2024/05/principles.jpg",
  "og-image": "%root%/content/images/2024/05/principles.jpg"
}
-->

You've probably encountered easing functions before. If you're a creative coder, you've likely heard of them or used them. If you're a user, you've certainly interacted with them. They're everywhere, and they give a little more life to computer generated animations.

## Taking it easy

For the uninitiated: let's say you've got a circle that you want to move from left to right over the course of a second. We can conceptualize this by converting the time into **progress**: a value between 0 and 1, representing how far through the animation we are. 0 represents the start of the animation, and 1 represents the end. Then, we can convert that progress to a position to draw the circle at.

<sketch code="true" version="2.0.3" width="200" height="200">
<code lang="js">
function setup() {
  createCanvas(200, 200);
}

function draw() {
  background('white');
  fill('red');

  let progress = map(millis() % 3000, 1000, 2000, 0, 1, true);
  let x = lerp(50, 150, progress);
  circle(x, height/2, 20);
}
</code>
</sketch>

This looks pretty mechanical. Animators may be able to articulate exactly why. A book written by Disney animators outlines the **12 principles of animation**, and these have become an essential part of an animation education. They're a set of things to think about as you animate to help bring characters believably to life (or, as rules to break at opportune moments for shock or comedy.) One of the principles is **slow in, slow out.** Basically: an object starting from rest takes some time to accelerate, and an object coming to a stop has to take time to decelerate. It's a high-level consequence of laws of physics, really. And our initial code violates it by suddenly jolting our circle to a constant speed, before suddenly stopping it again.

So what do you do about it? The answer for many is to slap an easing function on it! An easing function takes in a linear progress value, and returns a new progress value, but converted to nonlinear motion. Say you've <a href="https://openprocessing.org/sketch/2676129">copy-and-pasted in a stock easing function with an ease in and ease out.</a> Now, your code could look like this:

```js
let progress = map(millis(), 0, 2000, 0, 1, true);
progress = easeInOutCubic(progress);
let x = lerp(-width/3, width/3, progress);
circle(x, 0, 20);
```

Now, it looks a little more natural!

You've got some other options, too. If you want to add **overshoot**, another principle of animation, you could use `easeOutElastic`:

TODO

If you want one that also adds some **anticipation**, you could maybe use `easeInOutBack`:

TODO

All of these look way less mechanical than the original, and all set a different tone. Nice!

## It's not always easy street

If you're a programmer, you may even be able to clock specific easing functions by looking at them. That's maybe where the problems begin for me. There's just too few of them!

There's really nothing wrong with them. But you just end up picking one out of a couple stock choices, and that means you end up repeating them. In traditional animation, the principles are just guidelines; you still end up creating new unique motion each time based on what acting the scene calls for. Easing functions in code don't quite give you the flexibility to do that.

Some other alternatives have been proposed, though.

### Apple's kinematic easing functions

<a href="https://jcgt.org/published/0011/03/02/paper.pdf">A paper from Apple</a> describe a **parameterizable** easing function. It's a single function, but it lets you tweak some of its properties, including whether or not it includes anticipation, and if there's overshoot, how many oscillations it has. It's a great idea, but there are some papercuts I run into when using it.

- The workflow is, I set up a base linear motion with approximate timing. I then wrap the linear progress in this kinematic easing function, and tweak its parameters. When I adjust properties such as the number of oscillations, it also affects other properties I would want to hold constant, such as the size of the anticipation, so I end up having to twiddle with multiple parameters at once to narrow down on the intended result.
- Changing the number of oscillations also changes the *frequency* of the system: more oscillations makes the animation play faster unless you manually adjust the duration of the animation too. This gets at a fundamental issue with regular easing functions, too: you have to specify the timing and make it look good. What looks decent for cubic ease-in-ease-out may look unnaturally fast for elastic ease out.
- With no damping, the overshoot tends to feel like it comes to a sudden stop. If you look at a graph of progress over time, it looks like there is a slight kink at the end of the curve as it hits a steady state value of 1 at the end. This can be addressed by multiplying the easing function with an exponential fade out, but again it's a little tricky to get this right in general without having to change other properties of the function, like the size of the overshoot.

<img src="%root%/content/images/2025/07/kinematic.png" full="%root%/content/images/2025/07/kinematic.png" caption="A diagram from the paper showing oscillations, damping-free. If you extend the diagram out to the right at the steady state value, you can see where a visual jump will occur due to a kink in the motion curve." />

<a href="https://editor.p5js.org/davepagurek/sketches/WpwTr6_lZ">Here's a p5 web editor version</a>, if you want to play around yourself.

### Convolution filter

<a href="https://courses.cs.washington.edu/courses/cse464b/18wi/assignments/assignment_1/wang_2006.pdf">Another paper</a> describes an approach that breaks from easing functions: use the convolution of the original motion with a filter that adds an anticipation and overshoot. This is also a cool idea! It works on any stream of input, not just a single 0-1 transition progress. In the paper, they show a filtered version of simple linear motion. The resulting motion curve does in fact have anticipation and overshoot. The main issue I see is that the motion *speeds up* into the overshoot. This misunderstands something about overshoot, I think. Why would the object speed up there? Overshoot generally occurs because an object didn't start slowing down early enough, not because it sped up to go further. So I think this approach isn't quite practical; overshoot speed needs to be consistent with the speed going into the overshoot.

### Feedback control

Another non-easing-function approach that's decades old is to use a feedback control system to make an object follow a target.
