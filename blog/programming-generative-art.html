<!--
{
	"title": "Programming Generative Art",
	"category": "blog",
	"date": "2015-06-14",
	"excerpt": "The process of taking visuals and making them with programs.",
	"thumbnail": "%root%/content/images/2015/6/buildings-day-thumbnail.jpg"
}
-->

The other weekend I downloaded <a href="https://processing.org/" target="_blank">Processing</a> again. Processing is a language made for programming graphics built on top of Java (but can also be run in the browser through Processing.js.) It's stuff that can be done in any language that has a graphics library really, but Processing removes a lot of the boilerplate so you can just get to the programming. So that's why I opened it up, really - Processing calls programs "sketches" and its IDE a "sketchbook", and I wanted to just <em>make things</em> and try things out. And this is some of the stuff I learned. 

<h2>Everything is a fractal</h2>
I started out by making some trees. Trees, of course, are the classic fractal: a tree is essentially a branch, and every branch spouts more branches, and those branches spout more branches until your recursion limit is hit. Personally, for the style I wanted to go for, I set the recursion limit to 3, as the trees would not be large enough that smaller branches would really be seen anyway.

So, every time you make a new tree, you are really making a single branch. Then, in the constructor for that branch, it creates up to three new sub-branches. These sub-branches get put on a random side of the root and extend to a semi-random location. The randomness is to make everything less mathematical and precise and also to make the result change every time.

Here's the constructor for my Tree class, just for generating branches:
<code lang="processing">
Branch(float x, float y, float w, float h, int side) {
  branches = new ArrayList<Branch>();
  
  //Generate a random end location for each branch based on what side of the tree it's supposed to be on
  if (side == BRANCH_ROOT) {
    segmentX = x+(random(w*0.6)-w*0.3);
    segmentY = y-h*0.75+(random(h*0.3)-h*0.15);
  } else if (side == BRANCH_LEFT) {
    segmentX = x-random(w*0.3);
    segmentY = y-h*0.75+(random(h*0.3)-h*0.15);
  } else if (side == BRANCH_RIGHT) {
    segmentX = x+random(w*0.3);
    segmentY = y-h*0.75+(random(h*0.3)-h*0.15);
  }
  
  //Only make sub-branches if the recursion limit hasn't been met yet
  if (level < 3) {
    for (int i=0; i<BRANCH_MAX_LEVELS; i++) { //Count up to the maximum number of sub-branches possible
      if (random(1) >= 0.7) { //Only actually make some of them
        float branchY = random(segmentY, y);
        float branchX = x + ((segmentX - x)/(segmentY - y)) * (branchY - y);
        int branchDir = random(1) > 0.5 ? BRANCH_LEFT : BRANCH_RIGHT;
        branches.add(new Branch(branchX, branchY, w*0.6, h*0.5, branchDir, level+1, time));
      }
    }
  }
}
</code>

Then I have a separate `draw` method which first draws an ellipse around the end of each branch (the leaves) and then draws the branches on top. It ends up looking something like this:

<img src="%root%/content/images/2015/6/tree-medium.jpg" full="%root%/content/images/2015/6/tree.png" caption="It's simple, but that's the style I'm going for. They end up being pretty small anyway." />

Now, I started building houses the same way I was building trees. A house <a href="%root%/art/stilts/" target="_blank">in the style I wanted to make</a> is made of modular, interconnected units. How those units come together is extremely similar to how trees branch. Each unit can have different other units attached to it. Rather than simply drawing a line from root to tip, I drew a block with a roof and a random number of windows and stilts connecting them. It's a tree, with a different way of connecting branches.

<img src="%root%/content/images/2015/6/building-medium.jpg" full="%root%/content/images/2015/6/building.png" caption="How the buildings ended up looking." />

